\documentclass[paper,twocolumn]{geophysics}
%\documentclass[manuscript]{geophysics}
%\documentclass[manuscript,endfloat]{geophysics}
\usepackage{graphicx}
\usepackage{amsmath}
\newcommand{\mitbf}[1]{\mathbf{{#1}}}

\begin{document}

\title{
Tesseroids: forward modeling gravitational fields in spherical coordinates
}
\righthead{Tesseroids}
% manuscript number
\ms{Submission}

\author{
    Leonardo Uieda\footnotemark[1]\footnotemark[2],
    Val\'eria C. F. Barbosa\footnotemark[2],
    Carla Braitenberg\footnotemark[3],
    and
    Vanderlei C. Oliveira Jr\footnotemark[2]
}

\address{
\footnotemark[1]Universidade do Estado do Rio de Janeiro,
Rio de Janeiro, Brazil.
email: leouieda@gmail.com
\\
\footnotemark[2]Observat\'orio Nacional,
Rio de Janeiro, Brazil.
\\
\footnotemark[3]Department of Mathematics and Geosciences,
University of Trieste, Trieste, Italy.
}


\maketitle

\begin{abstract}
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}


We use the optimized formula of \citet{Grombein2013} with Cartesian integral
kernels.

The Cartesian kernels are faster to compute.

The Cartesian kernels don't have singularities in the poles.

The traditional spherical integral kernels suffer from a singularity at the
poles \citep{Heck2007, Wild-Pfeiffer2008}.

The Cartesian formula are numerically integrated using a Taylor series
expansion as proposed by \citet{Heck2007}.

The Taylor series expansion approach produces accurate results at low
latitudes.

The Taylor series expansion presents a decrease in accuracy towards the polar
regions.

The tesseroids have an approximately rectangular surface area at low latitudes
but collapse into an approximately triangular shape at the poles.

\citet{Grombein2013} use a near-zone separation to mitigate the increased error
in high latitudes.

In the so called "near-zone" of the computation point they use a finner
discretization with smaller tesseroids.

This is accomplished by dividing the tesseroids along the horizontal
dimensions.

The determination of an optimal size of the near-zone remains an open question
\citep{Grombein2013}.

We use the Gauss-Legendre Quadrature (GLQ) to numerically integrate the Cartesian
kernels instead of the Taylor series expansion \citep{Asgharzadeh2007}.

The GLQ integration consists of approximating the volume integral by a weighted sum of
the effect of point masses.

The point masses are distributed according to the roots of Legendre polynomials
\citep{Hildebrand1987}.

An advantage of the GLQ approach is that the accuracy of integration can be
controlled by the number of point masses used.

A disadvantage of the GLQ is the increased computation time as the number of
point masses increases.

There is a trade-off between accuracy and computation time.

\citet{Ku1977} suggests that the accuracy of the GLQ integration depends on
the ratio between distance to the computation point and the distance between
adjacent point masses.

\citet{Ku1977} proposes an empirical criteria that the distance between adjacent
point masses should be less than the distance to the computation point.

This empirical criteria was used by \citet{Asgharzadeh2007} as a way to
choose the number of point masses used in the GLQ integration.

They suggested using this criteria for gravitational attraction as well as
the gravity gradient tensor (or Marussi tensor) of a tesseroid.

\citet{Ku1977} presented results for the vertical component of the
gravitational acceleration ($g_z$) caused by a right rectangular prism.

To our knowledge, there has been no investigation if the empirical criteria of
\citet{Ku1977} is valid for the second derivatives of the
gravitational potential.

There has also been no attempt to quantify the error committed in the GLQ
integration of gravity gradients when applying the criteria of \citet{Ku1977}.

\citet{Li2011} devised an automatic algorithm to enforce the criteria of
\citet{Ku1977}.

Their algorithm keeps the number of points masses per tesseroid fixed.

They then check the ratio between the minimum distance to the computation point
and the largest dimension of the tesseroid.

If the ratio below a specified threshold value, the tesseroid is divided into
smaller tesseroids.

This division is repeated recursively until all tesseroids obey the criteria.

The GLQ integration is then performed for each of the smaller tesseroids
using the fixed number of point masses.

The algorithm of \citet{Li2011} is similar to the near-zone separation used by
\citet{Grombein2013}.

The advantage of the adaptive discretization of \citet{Li2011} over simply
increasing the number of points masses in the GLQ is that the
amount of point masses will be greater only close to the computation point.

This makes the adaptive discretization more computationally efficient.


We will attempt to quantify the error committed in the computation of the
gravity gradients using the GLQ with adaptive discretization.

We will establish an empirical relationship between the integration error and
the ratio between the distance to the computation point and the dimensions of
the tesseroid.

This will allow one to choose the appropriate amount of discretization to
achieve the desired accuracy.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Theory}


\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{figs/tesseroid}
    \caption{
        View of a tesseroid,
        the integration point $Q$ inside the tesseroid,
        a geocentric coordinate system $(X, Y, Z)$,
        the computation $P$ and it's local coordinate system $(x, y, z)$.
        $r$, $\phi$, $\lambda$ are
        the radius, latitude, and longitude, respectively, of point $P$,
        and $\ell$ is the Cartesian distance between $P$ and $Q$.
    }
    \label{fig:tesseroid}
\end{figure}

A tesseroid is a spherical mass element defined in geocentric spherical
coordinates
(Figure~\ref{fig:tesseroid}).
It is bounded by two meridians, two parallels, and two concentric circles.
The gravitational fields of a tesseroid at a point $P = (r,\phi,\lambda)$
are determined with respect to the local North-oriented coordinate system at
P (x, y, z in Figure~\ref{fig:tesseroid}).
\citet{Grombein2013} formulated Cartesian kernels for the volume integrals
that define the tesseroid gravitational potential, gravitational attraction,
and Marussi tensor, respectively,

\begin{equation}
    V(r,\phi,\lambda) = G \rho
        \int\limits_{\lambda_1}^{\lambda_2}
        \int\limits_{\phi_1}^{\phi_2}
        \int\limits_{r_1}^{r_2}
        \frac{1}{\ell}
        \kappa\  dr^\prime d\phi^\prime d\lambda^\prime,
    \label{eq:tesspot}
\end{equation}
\begin{equation}
    g_{\alpha}(r,\phi,\lambda) = G \rho
        \int\limits_{\lambda_1}^{\lambda_2}
        \int\limits_{\phi_1}^{\phi_2}
        \int\limits_{r_1}^{r_2}
        \frac{\Delta_\alpha}{\ell^3}
        \kappa\ dr^\prime d\phi^\prime d\lambda^\prime,
    \label{eq:tessgrav}
\end{equation}
\noindent
and
\begin{equation}
    g_{\alpha\beta}(r,\phi,\lambda) = G \rho
        \int\limits_{\lambda_1}^{\lambda_2}
        \int\limits_{\phi_1}^{\phi_2}
        \int\limits_{r_1}^{r_2}
        \left(
            \frac{3\Delta_{\alpha} \Delta_{\beta}}{\ell^5} -
            \frac{\delta_{\alpha\beta}}{\ell^3}
        \right)
        \kappa\ dr^\prime d\phi^\prime d\lambda^\prime.
    \label{eq:tesstensor}
\end{equation}

where $\alpha, \beta \in \{x, y, z\}$,
$\rho$ is the density,
$G = 0.00000000006673\ m^3kg^{-1}s^{-1}$ is the gravitational constant,
$\kappa = {r^\prime}^2 \cos \phi^\prime$,
and

\begin{eqnarray}
    \Delta_x &=& r^\prime\cos\phi\sin\phi^\prime - \sin\phi\cos\phi^\prime
                 \cos(\lambda^\prime - \lambda), \\
    \Delta_y &=& r^\prime \cos \phi^\prime \sin(\lambda^\prime - \lambda), \\
    \Delta_z &=& r^\prime \cos \psi - r,\\
    \ell &=& \sqrt{{r^\prime}^2 + r^2 - 2 r^\prime r \cos \psi}, \\
    \cos\psi &=& \sin\phi\sin\phi^\prime + \cos\phi\cos\phi^\prime
                 \cos(\lambda^\prime - \lambda).
\end{eqnarray}

We will follow \citet{Asgharzadeh2007} and perform the numerical integration
using the Gauss-Legendre Quadrature (GLQ).

The GLQ consists of approximating the integral by a weighted sum of the
integration kernel \citep{Hildebrand1987},
\begin{equation}
    \int\limits_a^b f(x) dx \approx
    \frac{b-a}{2}\sum\limits_{i=1}^N W_i f(x_i),
    \label{eq:glq1d}
\end{equation}

$N$ is the order of the quadrature, i.e. the number of points used in the GLQ.

The points $x_i$ where the kernel is evaluated are called the quadrature nodes.

The points are roots of the $N^{th}$ order Legendre polynomial $P_N(x)$.

The roots are $x = \pm 0.577350269$ for a second order polynomial ($P_2(x)$).

A root finder algorithm can be used to determine the roots for larger order
polynomials.

The second order roots, as well as the ones determined by a root finder
algorithm, will be within the range $[-1, 1]$.

Before being used for GLQ integration,
the roots must be scaled to the integration limits $[a, b]$ using

\begin{equation}
    x^{scaled}_i = \frac{b - a}{2} x_i + \frac{b + a}{2}.
    \label{eq:glq_scaling}
\end{equation}

The weights of the GLQ are given by \citep{Hildebrand1987},

\begin{equation}
    W_i = \frac{2}{(1 - x_i^2)(P^\prime_N(x_i))^2},
    \label{eq:glq_weights}
\end{equation}

The values of the $P_N(x)$ and its first derivative $P^\prime_N(x)$ can be
calculated with recursive relations.

The Gauss-Legendre Quadrature for volume integrals, like equations
\ref{eq:tesspot}, \ref{eq:tessgrav}, and \ref{eq:tesstensor},
becomes \citep{Asgharzadeh2007}

\begin{equation}
    \iiint\limits_{\Omega}
    f(r^\prime, \lambda^\prime, \phi^\prime)
    dr^\prime d\lambda^\prime d\phi^\prime
    \approx
    A
    \sum\limits_{i=1}^{N^r}
    \sum\limits_{j=1}^{N^\phi}
    \sum\limits_{k=1}^{N^\lambda}
    f(r_i, \phi_j, \lambda_k),
    \label{eq:glq3d}
\end{equation}

where

\begin{equation}
    A = \frac{(\lambda_2 - \lambda_1)(\phi_2 - \phi_1)(r_2 - r_1)}{8}.
\end{equation}

Applying equation~\ref{eq:glq3d} to equations
\ref{eq:tesspot}, \ref{eq:tessgrav}, and \ref{eq:tesstensor},
we see that $f(r_i, \phi_j, \lambda_k)$ is the effect of a point
mass located on the quadrature nodes.

It can be said that the GLQ integration approximates the volume integrals  by a
weighted sum of point mass effects.


The accuracy of the integration
depends on the number of point masses used in the summation.

\citet{Ku1977} showed that it also depends on the ratio between
the distance to the computation point and the distance between adjacent nodes.

Figure~\ref{fig:glqerrorsample}
illustrates this effect on the $g_{xy}$ gravity gradient component.

The $g_{xy}$ component was produced by a
$7^\circ \times 7^\circ \times 20\ km$ tesseroid
with $2.67\ g.cm^{-3}$ density
and top at $z=0\ km$.

The maps were calculated on a regular grid
with $100\times100$ points.

The GLQ order used was the same
in the radial, longitudinal, and latitudinal dimensions.

Figure~\ref{fig:glqerrorsample}a shows the $g_{xy}$ component
calculated at 400 km height using
GLQ with order two (two point masses in the longitude, latitude, and vertical
directions, respectively).

Figure~\ref{fig:glqerrorsample}b shows $g_{xy}$ computed with order two
GLQ as well but at 150 km height.

Notice that the computed effect is concentrated around each point mass
of the GLQ (black dots) and does not resemble the effect of a tesseroid.

\citet{Ku1977} determined an empirical criterion that the distance between
point masses (quadrature nodes) should be smaller than the minimum distance to
the computation point.

Thus, if a computation point is too close to the tesseroid one would have to
decrease the distance between the point masses in order to obtain an accurate
result.

One way to accomplish this would be increase the order of the quadrature
$N$ in all three directions.

Figure~\ref{fig:glqerrorsample}c shows the $g_{xy}$ component calculated at
150km height but with a GLQ order of 30.

The computed $g_{xy}$ component more closely resembles the results from
\citet{Asgharzadeh2007}.

\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{figs/vary-height-and-order}
    \caption{
        Example of the effect of varying
        the computation height
        and the number of point masses in the Gauss-Legendre Quadrature
        (i.e., the GLQ order).
        Black circles represent the horizontal location of the GLQ nodes
        (not shown for GLQ order 30).
        a) Field calculated at $400\ km$ height using GLQ order 2.
        The effect is similar to that presented by \citet{Asgharzadeh2007}.
        b) At $150\ km$ height and order 2,
        the field resembles that of
        four point sources located at the GLQ nodes.
        This effect was shown by \citet{Ku1977}
        for the case of the $g_z$ component of a right rectangular prism.
        c) At $150\ km$ but with a higher GLQ order of 30,
        the field is similar to that expected for a single mass source.
    }
    \label{fig:glqerrorsample}
\end{figure}


\subsection{Adaptive discretization}


Instead of increasing the GLQ order,
\citet{Li2011} proposed an alternative method
for decreasing the distance between point masses
and achieve an accurate integration.

Instead of increasing the GLQ order,
they divide the tesseroid into smaller tesseroids while keeping the number of
point masses per tesseroid fixed.

The gravitational effect of the larger tesseroid would be calculated as the sum
of the effects of the eight smaller tesseroids.

This division would effectively decrease the distance between nodes because of
the smaller tesseroids.

The criterion for dividing a tesseroid is that
the distance to the computation point must be smaller than
a constant times the size of the tesseroid.

The size of the tesseroid is used as a proxy for the distance between point
masses.

This procedure is repeated recursively
(i.e., to each of the smaller tesseroids)
until all tesseroids are within the acceptable distance-size ratio
or a minimum size is achieved.


The advantage of this adaptive discretization is that the number of point
masses is only increased in regions of the tesseroid that are closer to the
computation point.

Alternatively, simply increasing the order of the GLQ would increase the number
of point masses evenly throughout the whole tesseroid.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}

The calculation of the tesseroid gravitational fields with adaptive
discretization is implemented in the open-source package \textit{Tesseroids}.

Tesseroids is freely available under the BSD 3-clause free-software license.

An archived version of the source code is available along with this article.

The official website\footnote{http://www.leouieda.com/tesseroids}
hosts the software documentation and
archives of the latest binary executables and source code.

Ongoing development takes place through the source code hosting site
Github\footnote{https://github.com/leouieda/tesseroids}.



\textit{Tesseroids} is written in the C programming language.

Tesseroids consists of command-line programs.

Tesseroids tries to follow the Unix principals of
(1) making each program do one thing well,
(2) using plain text for input and output,
(3) making each program a ``filter'' that can be used in conjunction with other
programs.

The gravitational potential, attraction, and Marussi tensor components
are each computed by a separate program.

Programs for model and computation grid generation are also included.

The package also includes programs for computing the gravitational fields of
right rectangular prisms in Cartesian and spherical coordinates.

Tesseroids programs receive input through command-line arguments and the
standard input channel (STDIN) and output the results through
the standard output channel (STDOUT).

The command-line interface of each program was designed so that they
can be called in sequence using a Unix pipe.

For example, the command to
generate a regular grid with $NLON \times NLAT$ points,
calculate on it the $g_z$ and $g_{zz}$ caused by the tesseroids in file
MODELFILE,
and save the results to a file called OUTPUT
is:

\begin{verbatim}
tessgrd -rW/E/S/N -bNLON/NLAT -zHEIGHT | \
    tessgz MODELFILE | \
    tessgzz MODELFILE > OUTPUT
\end{verbatim}



The \texttt{src} folder of the distribution archive
contains the C files that build the command-line programs
(e.g., \texttt{tessgz.c}).

The \texttt{src/lib} folder contains the source files that implement the
numerical computations.

We will not describe here the implementation of the input/output parsing and
other miscellanea.

Instead, we will focus on the details of the Gauss-Legendre Quadrature
integration of equations~\ref{eq:tesspot},~\ref{eq:tessgrav},
and~\ref{eq:tesstensor}
and the adaptive discretization of tesseroids.



All figures and numerical experiments in this article were produced by the
IPython notebook\footnote{http://ipython.org}
files \citep{Perez2007} in the supplementary material.


These files combine the analysis source code
with explanatory text, equations, and the figures generated by the code.

This supplementary material can be run and executed locally or viewed
online\footnote{https://github.com/pinga-lab/paper-tesseroids}
(in a non-executable form).


\subsection{Numerical integration}

The source file \texttt{src/lib/glq.c} contains the code necessary to perform a
Gauss-Legendre Quadrature integration.

The first step in the GLQ is to compute the
locations of the point masses (i.e., the discretization points).

These points are roots of Legendre polynomials.

Precomputed values for these roots are available low order polynomials,
usually up to order 5.

For flexibility, we use the multiple root-finder algorithm of
\citet{Barrera-Figueroa2006} to compute the roots for polynomials of any order.

The additional computational load is minimal since the root-finder algorithm
must be run only once per program execution.

The root-finder algorithm is implemented in functions \texttt{glq\_nodes} and
\texttt{glq\_next\_root}.

The computed roots will be in the range $[-1, 1]$
and must be scaled to the integration limits (the limits of the tesseroid)
using function \texttt{glq\_set\_limits} (see equation~\ref{eq:glq_scaling}).

The GLQ weights are computed using equation~\ref{eq:glq_weights} by function
\texttt{glq\_weights}.

Both the computed roots and weights are stored in a data structure (a C
\texttt{struct}) called \texttt{GLQ}.

Function \texttt{glq\_new} allocates the memory necessary,
calculates the roots and weights,
and returns the complete \texttt{GLQ} structure.



The numerical integration is performed by the functions in module
\texttt{src/lib/grav\_tess.c}.

The functions \texttt{tess\_pot}, \texttt{tess\_gx}, \texttt{tess\_gy},
and so on, compute the gravitational fields of a single tesseroid on a single
computation point using the GLQ.

These functions require three \texttt{GLQ} structures that contain the roots
and weights for GLQ integration in the three dimensions.

The roots must be scaled to the
integration limits $[\lambda_1, \lambda_2], [\phi_1, \phi_2], [r_1, r_2]$
(see equations~\ref{eq:tesspot}-\ref{eq:tesstensor}).

The integration consists of three \texttt{for} loops that sum the weighted
kernel functions evaluated at each GLQ point mass (the scaled roots).

The evaluation of the trigonometric functions in
equations~\ref{eq:tesspot}-\ref{eq:tesstensor} inside the inner loops
are the biggest bottlenecks for the numerical integration.

Better performance is achieved by
precomputing the sine and cossine of latitudes
and moving some trigonometric function
evaluations to the outer loops.



\subsection{Implementation of adaptive discretization}


The adaptive discretization algorithm of \citet{Li2011}
divides a tesseroid recursively.

A tesseroid will be divided when the smallest distance between it and the
computation point is smaller than a constant times the largest dimension of the
tesseroid.

Instead of the smallest distance,
we use in our implementation
the distance $d$ between
the computation point $(r, \lambda, \phi)$
and the geometric center of the tesseroid
$(r_t, \lambda_t, \phi_t)$

\begin{equation}
    d = \left[
        r^2 + r_t^2 - 2 r r_t
        \cos(\sin\phi\sin\phi_t + \cos\phi\cos\phi_t
            \cos(\lambda - \lambda_t))
        \right]^{\frac{1}{2}}.
    \label{eq:distance}
\end{equation}

We define the dimensions of the tesseroid
along longitude, latitude, and radius, respectively, as
(see Figure~\ref{fig:division}a)

\begin{equation}
    L_\lambda = r_2 \arccos(\sin^2\phi_t +
        \cos^2\phi_t\cos(\lambda_2 - \lambda_1)),
    \label{eq:sizelon}
\end{equation}
\begin{equation}
    L_\phi = r_2 \arccos(\sin\phi_2\sin\phi_1 + \cos\phi_2\cos\phi_1),
\end{equation}
\begin{equation}
    L_r = r_2 - r_2.
    \label{eq:sizer}
\end{equation}

We fix the GLQ order $N=2$ for all three dimensions, resulting in eight point
masses in total.

The criterion we use to determine if a tesseroid must be divided is

\begin{equation}
    \frac{d}{L_i} < D,
    \label{eq:condition}
\end{equation}
\noindent
where $i \in (\lambda, \phi, r)$
and $D$ is a positive scalar called the ``distance-size ratio''.

$D$ determines how close the
computation point can be before we must divide the tesseroid.

Thus, the value of $D$ is indirectly responsible for
the accuracy of the solution and the computation time.

The modeling programs provide default values of $D$.

It can also be controlled through command-line arguments passed to the
programs.



We used a stack-based implementation of the algorithm instead of using
recursive function calls, as originally proposed by \citet{Li2011}.

Stacks are array-like data structures with a particular way of inserting and
removing elements from it.

In a stack, one can only insert elements on the top (the last empty position).

Likewise,
one can only remove the last element that was placed on the stack
(commonly referred to as ``popping'' the stack).

Stacks are also known as ``Last-in-first-out'', or LIFO, structures.

LIFOs are often described as being analogous to a stack of plates.

One can only place a new plate on the top of the stack and
can only remove a plate safely from the top of the stack.


We will describe the stack-based algorithm for a single tesseroid and
computation point.

The algorithm is implemented in function \texttt{calc\_tess\_model\_adapt}
of the file \texttt{src/lib/grav\_tess.c}.


Start by creating an empty stack of tesseroids.

The  stack is represented by the \texttt{stack} variable,
an array of \texttt{TESSEROID} structures.

We must define a maximum size for the stack to allocate memory for it.

Defining a maximum size allows us to avoid an infinite loop and large
consumption of computer memory in case the computation point is
on (or sufficiently close to) the surface of the tesseroid.

We use the integer \texttt{stktop} to keep track of the index of the last
element in the stack (the top of the stack).

The stack is initialized with the input tesseroid.

The initialization is done by copying the tesseroid into the stack and
setting \texttt{stktop} to zero (the first element).

Once the stack is initialized, the steps of the algorithm are:

\begin{enumerate}
    \item ``Pop'' the stack (i.e., take the last element from it).
        This will cause \texttt{stktop} to be reduced by one.
    \item Compute the distance $d$ between the tesseroid and
        the computation point (equation~\ref{eq:distance}).
    \item Compute the dimensions of the tesseroid $L_\lambda$, $L_\phi$,
        and $L_r$ (equations~\ref{eq:sizelon}-\ref{eq:sizer}).
    \item Check the condition in equation~\ref{eq:condition} for each
        dimension of the tesseroid.
    \item If none of the dimensions fail the above condition,
        compute the gravitational effect of the tesseroid using the
        Gauss-Legendre Quadrature with order two
        (equation~\ref{eq:glq3d}).
    \item If any of the dimensions fail the condition:
    \begin{enumerate}
        \item Divide the tesseroid in half along each dimension that failed
             the condition.
        \item Check if the number of new elements plus \texttt{stktop}
             is smaller than the maximum stack size.
             If it is not (i.e., the stack is full),
             warn the user of a ``stack overflow''
             and compute the effect of the larger tesseroid (step 5).
        \item If the stack is not full, place the smaller tesseroids into
             the stack.
    \end{enumerate}
    \item Repeat the above steps until the stack is empty
        (\texttt{stktop} is equal to -1).
\end{enumerate}


This stack-based implementation has some advantages over the original recursive
implementation suggested by \citet{Li2011}.

(1) It will be faster because it bypasses the overhead of function calls.

The speedup will be specially significant if the implementation is done
in high level interpreted languages, like Matlab and Python.

(2) It gives the developer more control over the recursion step.

In recursive implementations,
the developer has no control over the maximum number of consecutive
recursive calls (the ``recursion depth'').

This limit may vary with programming language, compiler, and operating system.

Overflowing the maximum recursion depth usually results in program
crashes with cryptic or inexistent error messages.

In the stack-based implementation, the developer has complete control.

Overflowing of the stack can be handled gracefully with an error message or
even performing a suitable approximation of the result.



Figure~\ref{fig:division} shows the effect of the distance-size ration $D$
in the adaptive discretization of a tesseroid for the computation at a point P.

Computing the gravitational effect of the tesseroid in
Figure~\ref{fig:division}a using the algorithm described above
is equivalent to computing the effect of the tesseroids in
Figures~\ref{fig:division}b-d.

Note that increasing the value of $D$ results in a finer mesh of tesseroids.

For $D = 1$ (Figure~\ref{fig:division}b) the number of tesseroids in the
adaptive discretization is 4,
for $D = 2$ (Figure~\ref{fig:division}c) it is 38,
and for $D = 6$ (Figure~\ref{fig:division}d) it is 936.


\begin{figure}
    \centering
    \includegraphics{figs/tesseroid-split}
    \caption{
        Adaptive discretization
        of the tesseroid shown in (a)
        for a computation point P
        using the distance-size ratio $D$ equal to
        (b) 1, (c) 2, and (d) 6.
        $d$ is the Cartesian distance between
        the center of the top face of the tesseroid
        and $P$.
        $L_r$, $L_\phi$, and $L_\lambda$ are the dimensions of the tesseroid.
        Note that increasing $D$
        results in a fine division of the tesseroid
        close the computation point
        and a coarser division further away.
    }
    \label{fig:division}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evaluation of the accuracy}

The key controlling point of their algorithm is the ratio between
the smallest distance to the computation point and
the largest side length of the tesseroid.

The value of this ratio is used to decide whether a tesseroid will be divided
or not.

Thus, the value chosen for the minimum allowed value of this ratio determines
how many divisions are made.

Consequently, the value for the minimum distance-size ratio controls both the
accuracy of the integration and the computation time.

\citet{Li2011} provide a few examples of values for this ratio in the case of
the vertical component of gravitational attraction.

However, there has been no further investigation into
the relationship between values of the minimum distance-size
ratio and the computation error.

It is also not clear whether the same relationship holds for the gravitational
attraction as well as for the gradient tensor components.

\subsection{$g_{zz}$ variability with computation height}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Acknowledgments}


\bibliographystyle{seg}
\bibliography{references.bib}
\end{document}
